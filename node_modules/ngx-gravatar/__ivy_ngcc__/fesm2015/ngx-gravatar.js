import { InjectionToken, ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, Inject, Directive, ElementRef, Renderer2, Input, NgModule } from '@angular/core';
import { Md5 } from 'ts-md5/dist/md5';

/**
 * Injection token for gravatar configuration
 */
import * as ɵngcc0 from '@angular/core';
const GRAVATAR_CONFIG_TOKEN = new InjectionToken('gravatarCustom.config');

// Visit https://en.gravatar.com/site/implement/images for more information
var FALLBACK;
(function (FALLBACK) {
    FALLBACK["blank"] = "blank";
    FALLBACK["identicon"] = "identicon";
    FALLBACK["mm"] = "mm";
    FALLBACK["mp"] = "mp";
    FALLBACK["monsterid"] = "monsterid";
    FALLBACK["retro"] = "retro";
    FALLBACK["robohash"] = "robohash";
    FALLBACK["wavatar"] = "wavatar";
})(FALLBACK || (FALLBACK = {}));
var RATING;
(function (RATING) {
    RATING["g"] = "g";
    RATING["pg"] = "pg";
    RATING["r"] = "r";
    RATING["x"] = "x";
})(RATING || (RATING = {}));

const DEFAULT_CONFIG = {
    fallback: FALLBACK.retro,
    size: 40,
    cornerRadius: 0,
    preferGravatar: false,
    hasBorder: false,
    borderColor: '#000000',
    borderRadius: '50%',
    borderStyle: 'solid',
    borderWidth: 1,
    round: true,
    backgroundColor: 'transparent',
    rating: RATING.g,
    ratio: 2,
};

class NgxGravatarService {
    constructor(gravatarConfig) {
        this.gravatarConfig = gravatarConfig;
        this.defaultConfig = Object.assign({}, DEFAULT_CONFIG);
        if (this.gravatarConfig) {
            this.defaultConfig = Object.assign(Object.assign({}, this.defaultConfig), this.gravatarConfig);
        }
    }
    /**
     * Return defaultConfig object
     */
    getDefaultConfig() {
        return this.defaultConfig;
    }
    /**
     * Generate gravatar url
     *
     * @param email is a string. If email is not a string, email will be set to empty string "" by default
     * @param md5Hash is a string. If value is given it will take precedence over email.
     * @param size number
     * @param rating string
     * @param fallback string
     * @return gravatar url
     */
    generateGravatarUrl(email, md5Hash, size = this.defaultConfig.size, rating = this.defaultConfig.rating, fallback = this.defaultConfig.fallback) {
        let emailHash;
        if (md5Hash) {
            emailHash = md5Hash;
        }
        else {
            try {
                email = email.trim().toLowerCase();
            }
            catch (e) {
                console.error(`[ngx-gravatar] - Email (${email}) is not a string. Empty string is used as a default email.`);
                email = '';
            }
            emailHash = Md5.hashStr(email);
        }
        return `https://www.gravatar.com/avatar/${emailHash}?s=${size}&r=${rating}&d=${fallback}`;
    }
}
NgxGravatarService.ɵfac = function NgxGravatarService_Factory(t) { return new (t || NgxGravatarService)(ɵngcc0.ɵɵinject(GRAVATAR_CONFIG_TOKEN, 8)); };
NgxGravatarService.ɵprov = ɵɵdefineInjectable({ factory: function NgxGravatarService_Factory() { return new NgxGravatarService(ɵɵinject(GRAVATAR_CONFIG_TOKEN, 8)); }, token: NgxGravatarService, providedIn: "root" });
NgxGravatarService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [GRAVATAR_CONFIG_TOKEN,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxGravatarService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [GRAVATAR_CONFIG_TOKEN]
            }] }]; }, null); })();

/* eslint-disable @angular-eslint/directive-selector */
class NgxGravatarDirective {
    constructor(elementRef, renderer, gravatarService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.gravatarService = gravatarService;
        this.style = {};
        this.initialized = false;
        this.defaultConfig = this.gravatarService.getDefaultConfig();
        // Listen for error when fetching custom src
        this.renderer.listen(this.elementRef.nativeElement, 'error', (event) => {
            if (!this.isGravatarUsed) {
                this.initializeAvatar(true); // Force using gravatar
            }
        });
    }
    ngOnInit() {
        this.initializeAvatar();
        this.initialized = true;
        this.isGravatarUsed = false;
    }
    ngOnChanges() {
        if (this.initialized) {
            this.initializeAvatar();
        }
    }
    /**
     * Set default values for user inputs if they are not provided
     */
    setDefaultValues() {
        this.size = this.computeSize();
        this.ratio =
            this.ratio === undefined ? this.defaultConfig.ratio : this.ratio;
        this.requestedSize = this.size * this.ratio;
        this.round =
            this.round === undefined ? this.defaultConfig.round : this.round;
        this.cornerRadius =
            this.cornerRadius === undefined
                ? this.defaultConfig.cornerRadius
                : this.cornerRadius;
        this.preferGravatar =
            this.preferGravatar === undefined
                ? this.defaultConfig.preferGravatar
                : this.preferGravatar;
    }
    /**
     * Initialize avatar.
     * Custom source has higher priority if preferGravatar is not set on.
     * Finally, set styles for the avatar.
     */
    initializeAvatar(forcedGravatar) {
        this.setDefaultValues();
        let url = '';
        if (this.preferGravatar || forcedGravatar) {
            url = this.gravatarService.generateGravatarUrl(this.email, this.md5Hash, this.requestedSize, this.rating, this.fallback);
            this.isGravatarUsed = true;
        }
        else {
            // this.preferGravatar == false
            if (this.src) {
                url = this.src;
            }
            else {
                // fallback to gravatar
                url = this.gravatarService.generateGravatarUrl(this.email, this.md5Hash, this.requestedSize, this.rating, this.fallback);
                this.isGravatarUsed = true;
            }
        }
        this.renderer.setProperty(this.elementRef.nativeElement, 'src', url);
        this.setStyle(this.avatarStyle());
    }
    /**
     * Compute the size of the avatar
     *
     * @return size
     */
    computeSize() {
        let size = this.size === undefined ? this.defaultConfig.size : this.size;
        if (this.style && this.style.width) {
            try {
                const width = this.style.width.trim();
                if (width.match(/^\d+px$/)) {
                    // width with px unit
                    size = width.replace('px', '');
                }
            }
            catch (e) {
                return size;
            }
        }
        return size;
    }
    /**
     * Compute style object
     *
     * @return style object
     */
    avatarStyle() {
        const style = {
            width: this.size + 'px',
            height: this.size + 'px',
            borderRadius: this.round
                ? this.defaultConfig.borderRadius
                : this.cornerRadius + 'px',
            borderStyle: this.defaultConfig.hasBorder || this.borderColor || this.borderWidth
                ? this.defaultConfig.borderStyle
                : 'none',
            borderColor: this.borderColor
                ? this.borderColor
                : this.defaultConfig.borderColor,
            borderWidth: this.borderWidth
                ? this.borderWidth + 'px'
                : this.defaultConfig.borderWidth + 'px',
            backgroundColor: this.backgroundColor
                ? this.backgroundColor
                : this.defaultConfig.backgroundColor,
        };
        return Object.assign(Object.assign({}, style), this.style);
    }
    /**
     * Set style for the avatar
     *
     * @param styles style object
     */
    setStyle(styles) {
        Object.keys(styles).forEach((key) => {
            this.renderer.setStyle(this.elementRef.nativeElement, key, styles[key]);
        });
    }
}
NgxGravatarDirective.ɵfac = function NgxGravatarDirective_Factory(t) { return new (t || NgxGravatarDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NgxGravatarService)); };
NgxGravatarDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxGravatarDirective, selectors: [["", "ngx-gravatar", ""], ["", "ngxGravatar", ""]], inputs: { style: "style", size: "size", ratio: "ratio", round: "round", cornerRadius: "cornerRadius", preferGravatar: "preferGravatar", src: "src", email: "email", md5Hash: "md5Hash", fallback: "fallback", rating: "rating", borderColor: "borderColor", borderWidth: "borderWidth", backgroundColor: "backgroundColor" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NgxGravatarDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgxGravatarService }
];
NgxGravatarDirective.propDecorators = {
    src: [{ type: Input }],
    email: [{ type: Input }],
    md5Hash: [{ type: Input }],
    size: [{ type: Input }],
    fallback: [{ type: Input }],
    rating: [{ type: Input }],
    round: [{ type: Input }],
    cornerRadius: [{ type: Input }],
    borderColor: [{ type: Input }],
    borderWidth: [{ type: Input }],
    style: [{ type: Input }],
    preferGravatar: [{ type: Input }],
    backgroundColor: [{ type: Input }],
    ratio: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxGravatarDirective, [{
        type: Directive,
        args: [{
                selector: '[ngx-gravatar], [ngxGravatar]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: NgxGravatarService }]; }, { style: [{
            type: Input
        }], size: [{
            type: Input
        }], ratio: [{
            type: Input
        }], round: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], preferGravatar: [{
            type: Input
        }], src: [{
            type: Input
        }], email: [{
            type: Input
        }], md5Hash: [{
            type: Input
        }], fallback: [{
            type: Input
        }], rating: [{
            type: Input
        }], borderColor: [{
            type: Input
        }], borderWidth: [{
            type: Input
        }], backgroundColor: [{
            type: Input
        }] }); })();

class GravatarModule {
    static forRoot(gravatarConfig) {
        return {
            ngModule: GravatarModule,
            providers: [
                {
                    provide: GRAVATAR_CONFIG_TOKEN,
                    useValue: gravatarConfig,
                },
            ],
        };
    }
}
GravatarModule.ɵfac = function GravatarModule_Factory(t) { return new (t || GravatarModule)(); };
GravatarModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: GravatarModule });
GravatarModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GravatarModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxGravatarDirective],
                exports: [NgxGravatarDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GravatarModule, { declarations: [NgxGravatarDirective], exports: [NgxGravatarDirective] }); })();

/*
 * Public API Surface of ngx-gravatar
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FALLBACK, GravatarModule, NgxGravatarService, RATING, NgxGravatarDirective as ɵa, GRAVATAR_CONFIG_TOKEN as ɵb };

//# sourceMappingURL=ngx-gravatar.js.map